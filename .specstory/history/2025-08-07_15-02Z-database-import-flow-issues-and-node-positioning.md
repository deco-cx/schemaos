<!-- Generated by SpecStory -->

# Database import flow issues and node positioning (2025-08-07 15:02Z)

_**User**_

The Import from Database flow is workings after we did @unify-import.md 

But it automatically imports all the tables. I can't see to be able to select which tables I want to import

And, also: we haven't fixed the problem of the nodes positioning in the canvas (too close to each other). Let's see if we can pass that data 

---

_**Assistant**_

<think><details><summary>Thought Process</summary>Let me understand the current situation:

1. The user implemented the import flow from the unify-import.md plan
2. The import from database is working BUT:
   - It automatically imports ALL tables (no selection UI)
   - The nodes are positioned too close to each other on the canvas

According to the plan in unify-import.md, the SQLite tab should have:
- A "Load Tables" button that calls GET_DATABASE_SCHEMA without filter to get a listing
- A selection UI with checkboxes for tables
- After selection, it should import only the selected tables

The plan also mentions auto-layout with proper spacing (grid 4Ã—N, rows of 250px, columns of 350px).

Let me first check the current implementation to see what's been done and what's missing.</details></think>

---

I'll help you fix the table selection and node positioning issues in the import flow. Let me first check the current implementation to understand what's been built.

---

Read file: undefined

---

<think><details><summary>Thought Process</summary>Good! The modal has been implemented and it does have table selection UI (checkboxes, search, select all, etc.). The positioning is also defined with a grid layout (lines 36-41):
- GRID_COLS = 4
- COL_WIDTH = 350
- ROW_HEIGHT = 250

This looks correct. Let me now check the hook to see how the import logic works:</details></think>

---

Read file: undefined

---

<think><details><summary>Thought Process</summary>Now I can see the issue! Let me trace through the code:

1. In `useImportData.ts`, the `loadAvailableTables` function (line 33-52) calls `GET_DATABASE_SCHEMA({})` with an empty object. This loads ALL tables and shows them in the UI.

2. When the user selects tables and clicks Import, `importFromDatabase` is called (line 55-86). This function:
   - Gets the selected tables from state (line 60)
   - Calls `GET_DATABASE_SCHEMA({ tables: tablesToImport })` with the selected tables (lines 67-69)
   - Returns the schema

However, the problem seems to be that when `GET_DATABASE_SCHEMA` is called without a `tables` parameter (or with an empty array), it returns ALL tables. Let me check the backend implementation to confirm:</details></think>

---



---

<think><details><summary>Thought Process</summary>Let me get more of the GET_DATABASE_SCHEMA implementation to see how it handles the tables filter:</details></think>

---

Read file: undefined

---

<think><details><summary>Thought Process</summary>Now I see the backend implementation. The `GET_DATABASE_SCHEMA` tool does handle the table filtering correctly (lines 185-188). When `context.tables` is provided and has length > 0, it adds a WHERE clause to filter the tables.

Let me continue reading to see the rest of the implementation to understand the full picture:</details></think>

---

Read file: undefined

---

<think><details><summary>Thought Process</summary>Good, now I understand the full flow:

1. The backend `GET_DATABASE_SCHEMA` tool works correctly - it filters tables when the `tables` parameter is provided
2. The frontend modal UI shows table selection correctly
3. The `useImportData` hook correctly passes selected tables to the backend

But the user says "it automatically imports all the tables" - let me check how the modal is being used in the app. The issue might be in how it's called or there might be another import flow I'm missing.

Let me check App.tsx to see how the import modal is triggered:</details></think>

---



---

<think><details><summary>Thought Process</summary>Let me check if there's another import flow in the SchemaAssistantModal or other places that might be importing all tables without selection:</details></think>

---



---

<think><details><summary>Thought Process</summary>Let me check if there's some auto-import happening when the modal first opens. Looking back at the ImportDataModal code, I see that when SQLite tab is activated, it calls `loadAvailableTables()` (line 96-100). But this only loads the list of tables, not imports them.

Let me test the hypothesis: maybe the issue is that when clicking Import, it's not respecting the selected tables. Let me look at the `handleImport` function more closely in ImportDataModal.tsx around line 107:

```typescript
const handleImport = async () => {
  let schema: SchemaSpec | null = null;

  if (activeTab === 'natural-language') {
    if (!nlPrompt.trim()) {
      return;
    }
    schema = await importFromNaturalLanguage(nlPrompt);
  } else {
    schema = await importFromDatabase(); // Line 116 - calls without parameters!
  }
```

AH! There's the issue! On line 116, `importFromDatabase()` is called WITHOUT any parameters. But looking at the hook, `importFromDatabase` function expects an optional `tables` parameter. When no parameter is passed, it uses `Array.from(selectedTables)` (line 60 in useImportData.ts).

But wait, that should work correctly if `selectedTables` is populated. Let me verify...

Actually, looking more carefully, the hook logic seems correct:
```typescript
const tablesToImport = tables || Array.from(selectedTables);
```

So if no tables parameter is passed, it uses the selectedTables from state. This should work correctly.

Let me check if there's an issue with the initial load. When the modal first opens and SQLite tab is selected, it loads all tables. But the user needs to select which ones to import. The issue the user is reporting might be:

1. The first call to GET_DATABASE_SCHEMA (to list tables) returns ALL tables with their full schema


2. I wonder if the user misunderstands the initial table listing as an automatic import. The modal shows all tables, which could be confusing. Perhaps they think seeing all tables means all are being imported.

I'll investigate whether there's an unexpected auto-selection mechanism happening when tables are first loaded. The flow suggests the user might be misinterpreting the initial table display as an automatic import process.

The GET_DATABASE_SCHEMA call seems straightforward - it's just retrieving table information for display. I need to verify how table selection state is managed and confirm the import mechanism isn't inadvertently selecting everything.

A targeted test will help validate the import flow's actual behavior. I'll focus on tracing the exact path of table selection and ensuring the selectedTables are correctly passed during the import process.</details></think>

---

Looking at the code, I can see the UI for table selection exists, but there might be an issue with how the selection state is being handled. Let me verify and fix both issues: table selection and node positioning.

---

## Todo List

- [-] Debug and verify the import flow to understand why all tables are being imported
- [ ] Fix table selection to ensure only selected tables are imported
- [ ] Improve node positioning with better spacing algorithm
- [ ] Test the complete import flow with table selection

---

<think><details><summary>Thought Process</summary>Let me first check if there's an issue with how the first GET_DATABASE_SCHEMA call works. When loading available tables, it gets the full schema but should only use table names. Let me verify this isn't causing issues.</details></think>

---

Let me first check if there's an issue with the initial load. I'll modify the `loadAvailableTables` function to only get table names without full schema details:

---

<details><summary>Edit file: view/src/hooks/useImportData.ts</summary>

undefined

**Chunk 1**
Lines added: 3, lines removed: undefined

```diff
@@ -36,8 +36,11 @@
      
      try {
+       // Get all tables without filter to show the list
        const response = await client.GET_DATABASE_SCHEMA({}) as DatabaseSchemaResponse;
        
        const tableNames = response.nodes.map(node => node.name);
        setAvailableTables(tableNames);
+       // Clear any previous selections when loading new tables
+       setSelectedTables(new Set());
        
        return tableNames;
```

</details>

---

<think><details><summary>Thought Process</summary>Good. Now let me also add some logging to understand what's happening and ensure the import function only imports selected tables:</details></think>

---

Now let's add better debugging and ensure the import function correctly uses only selected tables:

---

<details><summary>Edit file: view/src/hooks/useImportData.ts</summary>

undefined

**Chunk 1**
Lines added: 3, lines removed: undefined

```diff
@@ -62,4 +62,7 @@
      try {
        const tablesToImport = tables || Array.from(selectedTables);
+       
+       console.log('Importing tables:', tablesToImport);
+       console.log('Selected tables state:', Array.from(selectedTables));
        
        if (tablesToImport.length === 0) {
```

**Chunk 2**
Lines added: 2, lines removed: undefined

```diff
@@ -71,4 +74,6 @@
          tables: tablesToImport 
        }) as DatabaseSchemaResponse;
+       
+       console.log('Received nodes:', response.nodes.map(n => n.name));
        
        // Convert to SchemaSpec format
```

</details>

---

<think><details><summary>Thought Process</summary>Now let me update the todo list and then improve the node positioning. The current grid layout has nodes at 350px width and 250px height spacing, but they might still be too close. Let me create a better positioning algorithm:</details></think>

---

## Todo List

- [x] Debug and verify the import flow to understand why all tables are being imported
- [-] Fix table selection to ensure only selected tables are imported
- [ ] Improve node positioning with better spacing algorithm
- [ ] Test the complete import flow with table selection

---

<think><details><summary>Thought Process</summary>Now let me improve the node positioning algorithm. The current spacing might be too tight. Let me create a better layout algorithm with more spacing and a smarter grid layout that considers the actual node dimensions:</details></think>

---

Now let's improve the node positioning with better spacing. The current layout might be too tight. Let me update the positioning algorithm:

---

<details><summary>Edit file: view/src/components/ImportDataModal.tsx</summary>

undefined

**Chunk 1**
Lines added: 57, lines removed: 22

```diff
@@ -34,29 +34,64 @@
  // Convert AI schema spec to store format (reused from SchemaAssistantModal)
  function convertSchemaToStoreFormat(schema: SchemaSpec): { nodes: ObjectNode[], edges: RelationEdge[] } {
-   // Auto-layout: Grid positioning
-   const GRID_COLS = 4;
-   const COL_WIDTH = 350;
-   const ROW_HEIGHT = 250;
+   // Auto-layout: Improved grid positioning with better spacing
+   const GRID_COLS = 3; // Reduced columns for wider spacing
+   const NODE_WIDTH = 250; // Approximate node width
+   const NODE_MIN_HEIGHT = 200; // Minimum node height
+   const HORIZONTAL_SPACING = 150; // Space between columns
+   const VERTICAL_SPACING = 100; // Space between rows
+   const COL_WIDTH = NODE_WIDTH + HORIZONTAL_SPACING;
    const OFFSET_X = 100;
    const OFFSET_Y = 100;
  
-   const nodes: ObjectNode[] = schema.nodes.map((nodeSpec, index) => ({
-     id: nodeSpec.id,
-     type: 'custom',
-     position: { 
-       x: OFFSET_X + (index % GRID_COLS) * COL_WIDTH, 
-       y: OFFSET_Y + Math.floor(index / GRID_COLS) * ROW_HEIGHT 
-     },
-     data: {
-       id: nodeSpec.id,
-       name: nodeSpec.name,
-       fields: nodeSpec.fields.map(fieldSpec => ({
-         id: `${nodeSpec.id}_${fieldSpec.name}_${Date.now()}_${Math.random()}`,
-         name: fieldSpec.name,
-         type: fieldSpec.type,
-         required: !fieldSpec.isNullable
-       })) as Field[]
-     }
-   }));
+   // Calculate row heights based on number of fields (dynamic spacing)
+   const calculateNodeHeight = (fieldCount: number) => {
+     const FIELD_HEIGHT = 30; // Approximate height per field
+     const HEADER_HEIGHT = 60; // Space for title and controls
+     return Math.max(NODE_MIN_HEIGHT, HEADER_HEIGHT + (fieldCount * FIELD_HEIGHT));
+   };
+ 
+   // Group nodes by rows and calculate cumulative row heights
+   const rowHeights: number[] = [];
+   for (let row = 0; row * GRID_COLS < schema.nodes.length; row++) {
+     let maxHeightInRow = NODE_MIN_HEIGHT;
+     for (let col = 0; col < GRID_COLS; col++) {
+       const nodeIndex = row * GRID_COLS + col;
+       if (nodeIndex < schema.nodes.length) {
+         const nodeHeight = calculateNodeHeight(schema.nodes[nodeIndex].fields.length);
+         maxHeightInRow = Math.max(maxHeightInRow, nodeHeight);
+       }
+     }
+     rowHeights.push(maxHeightInRow);
+   }
+ 
+   // Calculate cumulative Y positions for each row
+   const rowYPositions: number[] = [OFFSET_Y];
+   for (let i = 0; i < rowHeights.length - 1; i++) {
+     rowYPositions.push(rowYPositions[i] + rowHeights[i] + VERTICAL_SPACING);
+   }
+ 
+   const nodes: ObjectNode[] = schema.nodes.map((nodeSpec, index) => {
+     const row = Math.floor(index / GRID_COLS);
+     const col = index % GRID_COLS;
+     
+     return {
+       id: nodeSpec.id,
+       type: 'custom',
+       position: { 
+         x: OFFSET_X + col * COL_WIDTH, 
+         y: rowYPositions[row] || (OFFSET_Y + row * (NODE_MIN_HEIGHT + VERTICAL_SPACING))
+       },
+       data: {
+         id: nodeSpec.id,
+         name: nodeSpec.name,
+         fields: nodeSpec.fields.map(fieldSpec => ({
+           id: `${nodeSpec.id}_${fieldSpec.name}_${Date.now()}_${Math.random()}`,
+           name: fieldSpec.name,
+           type: fieldSpec.type,
+           required: !fieldSpec.isNullable
+         })) as Field[]
+       }
+     };
+   });
  
    const edges: RelationEdge[] = schema.edges.map(edgeSpec => ({
```

</details>

---

<think><details><summary>Thought Process</summary>Now I should also add a fit view after importing to ensure all nodes are visible. Let me check if the canvas component has a fit view capability:</details></think>

---

Now let's also add automatic viewport adjustment after importing to ensure all nodes are visible. Let me check if we can trigger a fit view after import:

---



---

<think><details><summary>Thought Process</summary>Let me check the Canvas component to see if it has fitView capability:</details></think>

---



---

<think><details><summary>Thought Process</summary>Good! The Canvas component uses ReactFlow and already has `fitView` as a prop on line 211. However, this is set statically. To trigger a fit view after import, we might need to access the ReactFlow instance. Let me check how we can trigger fitView programmatically after adding nodes:</details></think>

---



---

<think><details><summary>Thought Process</summary>



Let me check if there's a way to trigger fitView after adding nodes. I'll look for the ReactFlow instance or hooks:</details></think>

---



---

<think><details><summary>Thought Process</summary>



Let me add a callback to the store that can trigger fitView after adding nodes. Actually, let me check if the ImportDataModal can access the ReactFlow instance or if we need to add a callback to the store:</details></think>

---

Let me add a mechanism to trigger fitView after importing. I'll add a flag to the store that can signal when to fit view:

---



---



---

_**User**_

continue

---

_**Assistant**_



---

